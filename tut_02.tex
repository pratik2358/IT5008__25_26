\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{hyperref}
\usepackage{outlines}
\usepackage{graphicx}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{amsmath,amssymb}
\usepackage{moresize}
\usepackage{tikz}
\usetikzlibrary{overlay-beamer-styles}
\usepackage{microtype}
\usepackage[
  backend=biber,
  style=alphabetic,
]{biblatex}
\usepackage{latexsym,multicol,booktabs,calligra}
\usepackage{listings,stackengine}
\usepackage[table,dvipsnames]{xcolor}
\usepackage{cancel}
\renewcommand{\figurename}{Figure}
\renewcommand{\algorithmname}{Algorithm}

\usepackage{SHU}
\setbeamersize{text margin left=7mm, text margin right=7mm}
\def\cmd#1{\texttt{\color{red}\footnotesize $\backslash$#1}}
\def\env#1{\texttt{\color{blue}\footnotesize #1}}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{halfgray}{gray}{0.55}
\definecolor{nus-orange}{RGB}{239,124,0}
\definecolor{nus-white}{RGB}{255,255,255}
\definecolor{nus-blue}{RGB}{0,61,124}
\definecolor{nus-black}{RGB}{0,0,0}

\newcommand\vscore{\mathsf{VScore}}
\newcommand\Fontvi{\fontsize{6}{7.2}\selectfont}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\NN}{\mathbb{N}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\lstset{
  language=SQL,
  basicstyle=\ttfamily\footnotesize,
  keywordstyle=\bfseries\color{nus-blue},
  emphstyle=\ttfamily\color{nus-blue},
  stringstyle=\color{deepgreen},
  numbers=left,
  numberstyle=\small\color{halfgray},
  rulesepcolor=\color{nus-orange},
  frame=shadowbox,
  showstringspaces=false,
  breaklines=true,
  breakatwhitespace=true,
  keepspaces=true,
  columns=flexible,
  upquote=true
}

\author{\href{https://pratik2358.github.io/}{Pratik Karmakar}}
\title{IT5008: Tutorial 2 — Simple Queries}
\institute{
  School of Computing,\\
  National University of Singapore
}
\date{AY25/26 S1}

\begin{document}
\begin{frame}
  \titlepage
  \begin{figure}[htpb]
    \begin{center}
      \includegraphics[keepaspectratio, scale=0.18]{nus-logo.png} % adjust path if needed
    \end{center}
  \end{figure}
\end{frame}
\section{Setup}
\begin{frame}{Scenario}
\small
Students at the \textbf{National University of Ngendipura (NUN)} buy, lend, and borrow books.\\
NUNStA commissions \emph{Apasaja Private Limited} to implement an online book exchange that records:
\begin{itemize}\itemsep3pt
  \item Student info: name, faculty, department, \textbf{email} (identifier), join date (\texttt{year}).
  \item Book info: title, authors, publisher, year, edition, \textbf{ISBN10}, \textbf{ISBN13} (industry IDs; \emph{unique}).
  \item Loans: \texttt{borrowed} date, \texttt{returned} date (may be \texttt{NULL}).
\end{itemize}
Auditing keeps data for (i) copies with loans and (ii) graduated students with loaned books. \\
This tutorial uses the schema/data created in “Creating and Populating Tables”.
\end{frame}

\begin{frame}{Important Constraints for This Tutorial}
\Large
\begin{block}{Use \emph{simple queries only}}
No \textbf{nested} or \textbf{aggregate} queries in answers. \\
Focus on \textbf{single-table} and \textbf{multi-table} joins and set operators.
\end{block}
\normalsize
We’ll present \textbf{equivalent} formulations (e.g., CROSS JOIN vs INNER JOIN, \texttt{UNION/INTERSECT/EXCEPT}) and discuss readability best practices.
\end{frame}
\section{Questions}
\begin{frame}{Questions — Single-table}
\footnotesize
\textbf{1.\ Single-Table Queries}
\begin{enumerate}\itemsep2pt
  \item[(a)] Print the different departments.
  \item[(b)] Print the different departments in which students are enrolled.
  \item[(c)] For each copy that has been borrowed and returned, print the \texttt{ISBN13} and the loan \textbf{duration}. Order by \texttt{ISBN13} (ASC) then duration (DESC). Use a \textbf{single} table.
\end{enumerate}
\end{frame}

\begin{frame}{Questions — Multi-table}
\footnotesize
\textbf{2.\ Multi-Table Queries}
\begin{enumerate}\itemsep2pt
  \item[(a)] For each unreturned loan of a book published by \texttt{'Wiley'}, print: book title, owner name+faculty, borrower name+faculty.
  \item[(b)] Print emails of students who \emph{borrowed or lent} a copy \textbf{before} they joined the University.
  \item[(c)] Print emails of students who \emph{borrowed or lent} a copy \textbf{on the day} they joined.
  \item[(d)] Print emails of students who \emph{borrowed and lent} a copy \textbf{on the day} they joined.
  \item[(e)] Print emails of students who \emph{borrowed but did not lend} a copy \textbf{on the day} they joined.
  \item[(f)] Print \texttt{ISBN13} of books that have \textbf{never} been borrowed.
\end{enumerate}
\end{frame}
\section{Solutions}

\begin{frame}[fragile]{1(a).\ Different departments (single table)}
\small
\textbf{Good practice:} alias tables; refer to columns via the alias.
\begin{lstlisting}
SELECT d.department
FROM department AS d;
\end{lstlisting}
\textbf{Why no DISTINCT?} \texttt{department} is the \textbf{PRIMARY KEY} of table \texttt{department}, so duplicates cannot occur.
\end{frame}

\begin{frame}[fragile]{1(b).\ Departments with enrolled students}
\small
Query the \texttt{student} table; many students share the same department, so we need \texttt{DISTINCT}.
\begin{lstlisting}
SELECT DISTINCT s.department
FROM student AS s;
\end{lstlisting}
\textbf{Wording matters.} If we asked “\emph{department of the different students}”, then \texttt{DISTINCT} should \textbf{not} be on \texttt{department} (students are identified by \texttt{email}, not department).
\end{frame}

\begin{frame}[fragile]{1(c).\ Loan duration from a single table (returned only)}
\small
\begin{lstlisting}[style=sqlcompact]  % compact style avoids wrapping/overflow
SELECT l.book, l.returned - l.borrowed + 1 AS duration
FROM loan AS l
WHERE l.returned IS NOT NULL
ORDER BY l.book ASC, duration DESC;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{1(c).\ Loan duration including unreturned}
\small Using COALESCE
\begin{lstlisting}[style=sqlcompact]
SELECT l.book,
       (COALESCE(l.returned, CURRENT_DATE)
        - l.borrowed + 1) AS duration
FROM loan AS l
ORDER BY l.book ASC, duration DESC;
\end{lstlisting}

\medskip Using CASE
\begin{lstlisting}[style=sqlcompact]
SELECT l.book,
       ((CASE WHEN l.returned IS NULL
              THEN CURRENT_DATE
              ELSE l.returned END)
        - l.borrowed + 1) AS duration
FROM loan AS l
ORDER BY l.book ASC, duration DESC;
\end{lstlisting}
\end{frame}

% Split long 2(a) into two frames
\begin{frame}[fragile]{2(a).\ Unreturned Wiley loans (with COPY join)}
\small
\begin{lstlisting}[style=sqlcompact]
SELECT b.title,
       s1.name AS ownerName,  d1.faculty AS ownerFaculty,
       s2.name AS borrowerName, d2.faculty AS borrowerFaculty
FROM loan AS l, book AS b, copy AS c,
     student AS s1, student AS s2,
     department AS d1, department AS d2
WHERE l.book = b.ISBN13
  AND c.book = l.book AND c.copy = l.copy AND c.owner = l.owner
  AND l.owner = s1.email AND l.borrower = s2.email
  AND s1.department = d1.department AND s2.department = d2.department
  AND b.publisher = 'Wiley'
  AND l.returned IS NULL;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{2(a).\ Unreturned Wiley loans (omit COPY via PK–FK)}
\small
\begin{lstlisting}[style=sqlcompact]
SELECT b.title,
       s1.name AS ownerName,  d1.faculty AS ownerFaculty,
       s2.name AS borrowerName, d2.faculty AS borrowerFaculty
FROM loan AS l, book AS b,
     student AS s1, student AS s2,
     department AS d1, department AS d2
WHERE l.book = b.ISBN13
  AND l.owner = s1.email  AND l.borrower = s2.email
  AND s1.department = d1.department AND s2.department = d2.department
  AND b.publisher = 'Wiley' AND l.returned IS NULL;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{2(a).\ Using \texttt{INNER JOIN} (clear ON vs WHERE)}
\small
\begin{lstlisting}[style=sqlcompact]
SELECT b.title,
       s1.name AS ownerName,    d1.faculty AS ownerFaculty,
       s2.name AS borrowerName, d2.faculty AS borrowerFaculty
FROM loan AS l
INNER JOIN book       AS b  ON l.book     = b.ISBN13
INNER JOIN student    AS s1 ON l.owner    = s1.email
INNER JOIN student    AS s2 ON l.borrower = s2.email
INNER JOIN department AS d1 ON s1.department = d1.department
INNER JOIN department AS d2 ON s2.department = d2.department
WHERE b.publisher = 'Wiley' AND l.returned IS NULL;
\end{lstlisting}
\textbf{Convention:} \texttt{ON} for PK–FK join predicates; \texttt{WHERE} for additional filters.
\end{frame}

\begin{frame}[fragile]{2(b).\ Borrowed or lent \emph{before} joining}
\small
\textbf{Either role} (owner or borrower) and \textbf{date check}:
\begin{lstlisting}
SELECT DISTINCT s.email
FROM loan AS l, student AS s
WHERE (s.email = l.borrower OR s.email = l.owner)
  AND l.borrowed < s.year;
\end{lstlisting}
\textbf{Distributed condition (equivalent):}
\begin{lstlisting}
SELECT DISTINCT s.email
FROM loan AS l, student AS s
WHERE (s.email = l.borrower AND l.borrowed < s.year)
   OR (s.email = l.owner    AND l.borrowed < s.year);
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{2(c).\ Borrowed or lent \emph{on} joining day}
\small
\textbf{Direct form (needs DISTINCT):}
\begin{lstlisting}
SELECT DISTINCT s.email
FROM loan AS l, student AS s
WHERE (s.email = l.borrower OR s.email = l.owner)
  AND l.borrowed = s.year;
\end{lstlisting}
\textbf{Using \texttt{UNION} (deduplicates by default):}
\begin{lstlisting}
SELECT s.email
FROM loan AS l, student AS s
WHERE s.email = l.borrower AND l.borrowed = s.year
UNION
SELECT s.email
FROM loan AS l, student AS s
WHERE s.email = l.owner AND l.borrowed = s.year;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{2(d).\ Borrowed \emph{and} lent \emph{on} joining day}
\small
\textbf{Using \texttt{INTERSECT}:}
\begin{lstlisting}
SELECT s.email
FROM loan AS l, student AS s
WHERE s.email = l.borrower AND l.borrowed = s.year
INTERSECT
SELECT s.email
FROM loan AS l, student AS s
WHERE s.email = l.owner AND l.borrowed = s.year;
\end{lstlisting}
\textbf{Without \texttt{INTERSECT}} (two aliases of \texttt{loan}):
\begin{lstlisting}[style=sqlcompact]
SELECT DISTINCT s.email
FROM loan AS l1, loan AS l2, student AS s
WHERE s.email = l1.borrower AND l1.borrowed = s.year
  AND s.email = l2.owner    AND l2.borrowed = s.year;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{2(e).\ Borrowed \emph{but did not lend} \emph{on} joining day}
\small
\begin{lstlisting}
SELECT s.email
FROM loan AS l, student AS s
WHERE s.email = l.borrower AND l.borrowed = s.year
EXCEPT
SELECT s.email
FROM loan AS l, student AS s
WHERE s.email = l.owner AND l.borrowed = s.year;
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]{2(f).\ Books \emph{never} borrowed}
\small
\textbf{Using \texttt{EXCEPT}:}
\begin{lstlisting}
SELECT b.ISBN13
FROM book AS b
EXCEPT
SELECT l.book
FROM loan AS l;
\end{lstlisting}
\textbf{Using \texttt{LEFT OUTER JOIN} + \texttt{IS NULL}:}
\begin{lstlisting}
SELECT b.ISBN13
FROM book AS b
LEFT OUTER JOIN loan AS l
  ON b.ISBN13 = l.book
WHERE l.book IS NULL;
\end{lstlisting}
\end{frame}

\section{Guidelines}
\begin{frame}{Guidelines \& Marking Tips}
\small
\begin{itemize}\itemsep4pt
  \item \textbf{No hardcoding.} Queries must work on any dataset consistent with the schema.
  \item \textbf{Constants only if stated.} If the question names a constant (e.g., 'Wiley'), you may use it; otherwise avoid.
  \item \textbf{Readable style.} Use table aliases, qualify columns, and uppercase SQL keywords.
  \item \textbf{Set operators} (\texttt{UNION/INTERSECT/EXCEPT}) inherently deduplicate; \texttt{DISTINCT} is redundant with them.
  \item \textbf{Partial marks:} (i) query executes, (ii) correct columns (names, types, order), (iii) minimal row differences.
\end{itemize}
\end{frame}

\begin{frame}
\begin{center}
Questions?\\
Drop a mail at: pratik.karmakar@u.nus.edu
\end{center}
\end{frame}

\end{document}